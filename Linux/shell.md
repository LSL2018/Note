[ ! -z $1 ]：

-z表示空

判断$1参数是否非空，返回一个值0或者1

 

awk  -F ":" '{print $1}' /etc/passwd   #以":"为分隔符打印/etc/passwd文件的每一行的第一列内容

a‘’wk -v的后面紧跟着变量名字和对变量的赋值，在awk语句中可以直接使用此变量

awk读取一行，切割成字段，以字段为单位，进行细节处理

 

$NF代表最后一个域 （也就是最后一个单词）

NF 代表一行有多少个域 （也就是一行有多少个单词）

grep -v：反向文本行搜索，显示不包含匹配文本的所有行

grep -E: 将样式为延伸的正则表达式来使用

grep -ri: 递归查询，除了查找指定文件里的内容还会查找指定文件同级子目录下的文件内容（-i 不区分大小写）

 

=~：正则匹配，用来判断其左侧的参数是否符合右边的要求，如果匹配就输出1，不匹配就输出0

 

if [[]]中引用变量不用加 双引号(")了，而if[]中变量必须加双引号，如if[ -n "$test" ]

 

grep -e 选项，只能传递一个参数。在单条命令中使用多个 -e 选项，得到多个pattern，以此实现OR操作

 

wc命令用于统计指定文件中的字节数、字数、行数，并将统计结果显示输出

-c 统计字节数

-l 统计行数

-m 统计字符数。该参数不能与-c一起使用

-w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串

-L 打印最长行的长度

 

 

文件比较运算符

-e filename 如果 filename存在，则为真 [ -e /var/log/syslog ]

-d filename 如果 filename为目录，则为真 [ -d /tmp/mydir ]

-f filename 如果 filename为常规文件，则为真 [ -f /usr/bin/grep ]

-L filename 如果 filename为符号链接，则为真 [ -L /usr/bin/grep ]

-r filename 如果 filename可读，则为真 [ -r /var/log/syslog ]

-w filename 如果 filename可写，则为真 [ -w /var/mytmp.txt ]

-x filename 如果 filename可执行，则为真 [ -L /usr/bin/grep ]

 

 

ls 表示列出当前目录下的文件。后面的 -lrt 是这个命令的一些选项补充。-lrt 实际上是代表了 "-l -r -t" 这三个选项集合

1）-l 表示开启长列表输出，打开了就会输出文件权限、引用计数、所有者、所属组、文件大小、修改日期和文件名称这些详细的信息。

2）-t 以时间排序，最新的文件会排在上面。

3）-r 表示反向排序、倒序输出。

4）-x 按列输出，横向排序。

5）-u 按照文件上次被访问的时间排序

 

lcd是FTP服务的内置命令,是在本地主机目录操作的命令

 

eval命令将会首先扫描命令行进行所有的替换，然后再执行命令。该命令使用于那些一次扫描无法实现其功能的变量。该命令对变量进行两次扫描。这些需要进行两次扫描的变量有时候被称为复杂变量

 

$( )中放的是命令，相当于` `，例如todaydate=$(date +%Y%m%d)意思是执行date命令，返回执行结果给变量todaydate，也可以写为todaydate=`date +%Y%m%d`；

${ }中放的是变量，例如echo ${PATH}取PATH变量的值并打印，也可以不加括号比如$PATH

 

 touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件

 

su命令和su -命令最大的本质区别就是：前者只是切换了root身份，但Shell环境仍然是普通用户的Shell；而后者连用户和Shell环境一起切换成root身份了。只有切换了Shell环境才不会出现PATH环境变量错误。su切换成root用户以后，pwd一下，发现工作目录仍然是普通用户的工作目录；而用su -命令切换以后，工作目录变成root的工作目录了。用echo $PATH命令看一下su和su -以后的环境变量有何不同。以此类推，要从当前用户切换到其它用户也一样，应该使用su -命令，后面加上用户名即可。

 

通常 ‘Permission denied’ 错误的时候,需要执行 sudo 命令. 该命令会提高执行权限(通常是 root). 当然 使用 sudo -u username 会指定特定用户.

 

's/^\(..\)\(..\)\(..\)\(..\).*$/\1:\2:\3:\4/'

其中^表示从一行的开头匹配

第一个\(..\)表示匹配任意2个字符，并且后面的\1，就是这次匹配的结果。

对于字符串aabbccddeeffgghh而言，就是aa这2个字符

同理，第二\(..\)匹配bb，对应\2

第三\(..\)匹配cc，对应\3

第四\(..\)匹配dd，对应\4

剩下的eeffgghh匹配 .*$，其中.*表示匹配任意个字符，$匹配到末尾，这些字符串被抛弃

aabbccddeeffgghh得到的结果就是aa:bb:cc:dd

 

sed 's/foo/bar/' file # 只替换每一行中的第一个“foo”字串

sed 's/foo/bar/4' file # 只替换每一行中的第四个“foo”字串

sed 's/foo/bar/g' file # 将每一行中的所有“foo”都换成“bar”

sed -e 's/ [^ ]*$//' # 取出除最后一个参数外的其余参数

sed -e 's/.* //'  # 取出最后一个参数

 

uniq 命令用于检查及删除文本文件中重复出现的行列，直接用uniq命令可以去重，但当重复的行不相邻时，uniq 命令是不起作用的。所以，经常需要跟 sort 命令一起使用。

 

 

 

 

 

 